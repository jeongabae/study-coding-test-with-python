import sys
n = int(sys.stdin.readline().rstrip())
d = [0] * (n + 1)	# d[i]에 i를 1을 만들려고 할 때 연산을 사용하는 횟수의 최솟값을 저장!
for i in range(2, n + 1):

    d[i] = d[i - 1] + 1 #i가 2 or 3으로 나눠지지않는 경우 -1을 해줘야하므로 연산 횟수를 1증가시킨다고 먼저 해놓는다!
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)	# 근데 만약에 3으로 나눠지면 1을 빼는 방법과 3을 나누는 방법 중에 연산이 최소가 되는 걸 d[i]에 저장.
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1) # 근데 만약에 2으로 나눠지면 1을 빼는 방법과 3을 나누는 방법 중에 연산이 최소가 되는 걸 d[i]에 저장.
print(d[n])
"""나동빈님 풀이 (d의 항 개수 빼고는 내 풀이랑 아예 똑같음)
# 정수 X를 입력 받기
x = int(input())

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 1000001

# 다이나믹 프로그래밍(Dynamic Programming) 진행(보텀업)
for i in range(2, x + 1):
    # 현재의 수에서 1을 빼는 경우
    d[i] = d[i - 1] + 1
    # 현재의 수가 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)
    # 현재의 수가 3으로 나누어 떨어지는 경우
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
    # 현재의 수가 5로 나누어 떨어지는 경우
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)

print(d[x])
"""
"""순위권 풀이(내 풀이보다 훨씬 빠름 약 10배..)
# dp
def dp(n):
    if n in memo:
        return memo[n]
    # 나머지를 더해준 이유는...7의 경우 2, 3으로 나누어 지지 않으므로 1을 빼는 행동을 무조건 해줘야한다.
    # 이 경우를 연산 횟수에 포함하기 위해 나머지로 더해주는 것 같음.
    m = 1 + min(dp(n // 2) + n % 2, dp(n // 3) + n % 3) # 1 + 어떤 수 = 1..
    memo[n] = m
    return m

memo = {1: 0, 2: 1}
n = int(input())
print(dp(n))
"""
"""과정 예시
n = 10
m = 1 + min(dp(5)+0, dp(3) +1) = 1 + min(3,2) = 3

dp(5)
m = 1 + min(dp(2) + 1 , dp(1) + 2) = 1 + min(1+1, 0+2) = 3

dp(3)
m = 1 + min(dp(1)+1, dp(1)+0) = 1+min(1,0) = 1
"""